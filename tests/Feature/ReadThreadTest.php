<?php

namespace Tests\Feature;

use App\Models\Channel;
use App\Models\Reply;
use App\Models\Thread;
use App\Models\User;
use Tests\TestCase;

class ReadThreadTest extends TestCase
{

    protected $thread;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->thread = Thread::factory()->create();
    }

    /**
     * @test
     * 一个用户可以浏览所有帖子
     */
    public function a_user_can_view_all_threads()
    {
        $response = $this->get('/threads');
        $response->assertSee($this->thread->title);
    }

    /**
     * @test
     * 一个用户可以浏览帖子
     */
    public function a_user_can_read_a_single_thread()
    {
        $response = $this->get($this->thread->path());
        $response->assertSee($this->thread->title);
    }

    /**
     * @test
     * 用户可以能看到帖子的内容 也能看到回复
     */
    public function a_user_can_read_replies_that_are_associated_with_a_thread()
    {
        // 如果存在帖子
        // 并且该帖子拥有回复
        $reply = Reply::factory()->create(['thread_id' => $this->thread->id]);
        // 那么当我们看该帖子时
        // 我们也要看到回复
        $this->assertDatabaseHas('replies', ['body' => $reply->body]);
    }

    /**
     * @test
     * 用户可以根据频道筛选帖子
     */
    public function a_user_can_filter_threads_according_to_a_channel()
    {
        $channel = Channel::factory()->create();
        $threadInChannel = Thread::factory()->create(['channel_id' => $channel->id]);
        $threadNotInChannel = Thread::factory()->create();
        $this->get('/threads/' . $channel->slug)
            ->assertSee($threadInChannel->title)
            ->assertDontSee($threadNotInChannel->title);
    }

    /**
     * @test
     * 用户可以根据用户名筛选帖子
     */
    public function a_user_can_filter_threads_by_any_username()
    {
        $this->signIn(User::factory()->create(['name' => 'NoNo1']));
        $threadByNoNo1 = Thread::factory()->create(['user_id' => auth()->id()]);
        $threadNotbyNoNo1 = Thread::factory()->create();
        $this->get('/threads?by=NoNo1')
            ->assertSee($threadByNoNo1->title)
            ->assertDontSee($threadNotbyNoNo1->title);
    }

    /**
     * @test
     * 用户可以根据回复数来筛选帖子
     */
    public function a_user_can_filter_threads_by_popularity()
    {
        // 3个帖子
        // 一个 0 回复 一个有2个回复 一个有3个回复
        $thread = $this->thread;
        $threadWithTwoReplies = Thread::factory()->create();
        Reply::factory()->count(2)->create(['thread_id' => $threadWithTwoReplies->id]);
        $threadWithThreeReplies = Thread::factory()->create();
        Reply::factory()->count(3)->create(['thread_id' => $threadWithThreeReplies->id]);
        // 根据回复数来筛选
        $response = $this->getJson('/threads?popularity=1')->json();
        // 回复数由多到少
        $this->assertEquals([3, 2, 0], array_column($response['data'], 'replies_count'));

    }

    /**
     * @test
     * 用户可以根据一个帖子请求所有回复
     */
    public function a_user_can_request_all_replies_for_a_given_thread()
    {
        // 创建帖子
        $thread = Thread::factory()->create();
        // 创建多个回复
        $replies = Reply::factory()->count(40)->create(['thread_id' => $thread->id]);
        // 可以看到回复数量
        $response = $this->getJson($thread->path() . '/replies')->json();
        $this->assertCount(20, $response['data']);
        $this->assertEquals(40, $response['total']);
    }

    /**
     * @test
     * 用户可以根据没有回复来过滤帖子
     */
    public function a_user_can_filter_threads_by_those_that_are_unanswered()
    {
        // 创建帖子
        $thread = $this->thread;
        // 创建回复
        Reply::factory()->create();
        // 有两个帖子
        $this->assertDatabaseCount('threads', 2);
        // 无回复帖子只有一个
        $response = $this->getJson('threads?unanswered=1')->json();
        $this->assertCount(1, $response['data']);
    }

    /**
     * @test
     * 记录帖子的浏览次数
     */
    public function we_record_a_new_visit_each_time_the_thread_is_read()
    {
        $thread = Thread::factory()->create();
        $this->assertSame(0, $thread->visits);

        $this->call('GET', $thread->path());
        $this->assertEquals(1, $thread->fresh()->visits);
    }


}
